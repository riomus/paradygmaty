Lista 6
==========

Jeżeli zgłoszą się państwo z oodaniem zadania bez napisanych prostych testów, dostaną państwo 0 pkt bez możliwości poprawy danego zadania. 


1. Zaimplementuj szyfrowanie Cezara (zmiana znaku o K pozycji w alfabecie , gdzie K to klucz), implementacja ma być w pełni funkcyjna. Zaimplementuj zarówno szyfrowanie jak i deszyfrowanie. Domyślny klucz to 13


   Punkty: 3, **Scala**


2. Zaimplementuj obliczanie liczby [τ](https://tauday.com/tau-manifesto) (2*π) z wykorzystaniem strumieni


   Punkty: 4, **Ocaml**


3. Zaimplementuj funkcję która drukuje na ekran (STD OUT) trójkąt o zadanej głębokości (FUNKCYJNIE!). Funkcja ta ma najpierw zbudować trójkąt jako listę a następnie wydrukować 

	```
		*
		**
		***
		****
		*****
		******
		*******
	```

   Punkty: 2, **OCaml**


4. Zaimplementuj Option:

	1. Może mieć wartosć Some[T] lub None
	2. Posiada metodę unwrap która wywołana dla None rzuca błąd, dla Some zwraca wartość
	3. Posiada metodę isNone
	4. Some(null) to None
	5. Posiada metodę map która przyjmuje funkcję jednoargumentową przyjmującą wartość i zwracającą wartość (może być innego typu) ( jest generyczna T=>K)
	6. Posiada metodę flatMap , przyjującą funkcję jednoargumentową przyjmującą wartość a zwracającą Option\[U\] (po wykonaniu flatMap nie posiadamy Option[Option[U]] tylko Option[U])
	7. Option może być dopasowywany do wzorca. 

	Wszystko ma mieć przykłądowe wywołąnia (testy) 

   Punkty: 4, **Scala**


5.  Korzystając z rekurencji ogonowej i dopasowania do wzorca zaimplementuj pobieranie przedostaniego elementu listy.  

	Punkty 2, **oCaml**